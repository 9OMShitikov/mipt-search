# Index me!

В этом задании мы реализуем RAM-index, который в последствии будет сегментом
настоящего RT-index'а. 

RamIndex пока имеет достаточно простой интерфейс:
```
RamSegment() = default;
explicit RamSegment(const std::shared_ptr<IndexConfig> &pIndexConfig);

virtual void ExecuteSelect(const Query &tQuery);

void Flush(const std::string &sPath);

inline void SetData(const IndexData& data) { m_dDataIndex = data; };
inline IndexData GetData() const { return m_dDataIndex; };
```

Обратим внимание на следующие моменты:
* Конструктор от конфига должен инциализировать и индексировать данные описанные
в конфиге с учетом морфологии.
* Flush пока реализовать не нужно, его задачей будет перевод RAM сегмента в Disk
сегмент.
* SetData/GetData методы побольшей части нужные для тестирования.

Сам RAM сегмент хранит свои данные в структуре IndexData, которая является
хеш-таблицей от токена к вектору постингов.

Перед выполнением задания рекомендуем ознакомиться с структорой Query:
```
struct Query {
	std::string m_sIndexName;
	int m_iLimit = -1;

	std::vector<std::pair<std::wstring, uint32_t>> m_dMatchFieldMask;

	RankerType m_iRankerType;

	std::shared_ptr<Context> m_pContext;
};
```

В этом задании вам понадобятся поля m_dMatchFieldMask, m_iRankerType и
m_pContext.

* m_dMatchFieldMask - содержит в себе сам запрос в виде BOW. Первым элементом
пары выступает уже нормализованный токен, а втооым аргументом маска по каким
полям нужно искать. Пока будем считать, что маска содержит в себе все поля.
* m_iRankerType - типа ранкера, на данном этапе ранжирование (т.е. релевантность
мэтча будем оценивать как количество hit'ов. Понятно, что такая функция ранжирования
практически бесполезно, но сейчас это нужно как заглушка). Взгляните на класс DummyRanker.
Обратим внимание, что DummyRanker принимает в конструктор IndexStats, которые
тоже нужно посчитать на этапе индексирования.
* m_pContext - это некоторая связь с внешним миром для индекса, чтобы можно было
куда-то сохранять результат.

Реализуйте сначала метод ExecuteSelect. Если вы сделаете все правильно, то
должен заработь unit-тест `(DummyIndex) One word`. Хоть тест всего один и он простой
учтите, что если вы допустите на этом этапе ошибку, которую не отловите, то потом её
искать будет сильно сложнее. Поэтому строго рекомендуется написать свои тесты.
Хоть и будут принматься решения, которые заранее собирают набор хитов для каждого токена,
а потом их пересекают, мы все равно крайне рекомендуем написать реализацию процессинга 
"на лету" с помощью метода n-указателей. Тут стоит заметить о неприятном случае с дублирующимися
словами, но мы пока предлагаем считать, что таких случаев не бывает.

Затем реализуйте индексацию из файла. Не забывайте о морфологии!

Финальной частью задания будет связь сервера с выполнением запроса. Удостоверьтесь, что
на этапе запуска сервера индексируются сегменты с `type = dummy`. Затем допишите часть
в `lib/server/net/handlers.cpp`, где вы прнимали json-запрос. Вам нужно удалить заглушку и
реально вызвать запрос у индекса. Если вы сделаете все правильно, то должны заработать
интеграционные тесты TestJSONQuery (они появятся позже).